# StubGenerator

`StubGenerator` は、クラスパスに存在しない型定義（スタブ）を自動生成することで、Spoon などの静的解析ツールの解析精度を向上させるためのツールです。

## 機能

- **スタブ自動生成**: 欠落している型のクラス、インターフェース、アノテーションのスタブを生成します。
- **推論**: 使用状況に基づいてメソッド、フィールド、および型の種類（クラス/インターフェース/アノテーション）を推論します。
- **ネストされた型のサポート**: static なネストされたクラス（内部クラス）を適切に処理・生成します。
- **クラスパスの展開**: 解析時のクラスパスとしてディレクトリ（およびその中の全JARファイル）を指定可能です。
- **設定**: Javaのコンプライアンスレベルやソースコードのエンコーディングを設定可能です。

## 使用方法

**前提**: 以下のコマンドはすべて `java-call-tree-analyzer` ディレクトリ内で実行することを想定しています。

### ツールのビルド

`StubGenerator` の単体JARファイルをビルドするには、以下のコマンドを実行します：

```bash
./gradlew stubGeneratorJar
```

これにより、カレントディレクトリに `stub-generator-1.0.0.jar`（バージョンは `build.gradle` の設定に依存）が生成されます。

### ツールの実行

```bash
java -jar stub-generator-1.0.0.jar -s <source_dir> [options]
```

**オプション:**

*   `-s`, `--source <paths>`: (必須) 解析対象のソースディレクトリ（カンマ区切りで複数指定可）。
*   `-c`, `--classpath <paths>`: (任意) クラスパスエントリ（JARまたはディレクトリ）。ディレクトリを指定した場合、その中の全JARも追加されます。
*   `-o`, `--output <dir>`: (任意) スタブの出力先ディレクトリ。デフォルトは `stubs` です。
*   `-cl`, `--complianceLevel <level>`: (任意) Javaコンプライアンスレベル（例: 8, 11, 17, 21）。デフォルトは 21 です。
*   `-e`, `--encoding <charset>`: (任意) ソースコードのエンコーディング（例: UTF-8, Shift_JIS）。デフォルトは UTF-8 です。
*   `-d`, `--debug`: (任意) デバッグログを有効にします。
*   `-h`, `--help`: ヘルプメッセージを表示します。

### 実行例

```bash
java -jar stub-generator-1.0.0.jar -s app/src/main/java -o generated-stubs -cl 17
```

### スタブのコンパイルとパッケージ化

生成されたスタブをライブラリとして使用するために、コンパイルしてJARにパッケージ化することができます。

1.  **スタブの生成**: デフォルトのGradleタスク設定に合わせて、`app/build/generated/stubs` に出力することをお勧めします。

    ```bash
    # 例: 期待されるビルドディレクトリに出力
    java -jar stub-generator-1.0.0.jar -s app/src/main/java -o app/build/generated/stubs
    ```

2.  **スタブJARのビルド**:

    ```bash
    ./gradlew stubJar
    ```

    これにより以下の処理が行われます：
    1.  `app/build/generated/stubs` 内のJavaファイルをコンパイル。
    2.  コンパイルされたクラスを `generated-stubs-1.0.0.jar` としてカレントディレクトリに出力。

## 仕組み

1.  **解析**: ツールはSpoonを使用して指定されたソースコードを解析します。「no classpath」モードで動作し、依存関係が欠落していても動作します。
2.  **検出**: ソースコード内で参照されているが、定義が見つからない（ソース内にもクラスパスにもない）型を特定します。
3.  **推論**:
    *   **型の種類**: アノテーションとして使用されているか（`@Missing`）、インターフェースとして実装されているか（`implements Missing`）を判定します。それ以外はクラスとみなします。
    *   **ネストされた型**: 欠落している型が別の欠落している型の内部クラスである場合（例: `Missing.Inner`）、構造を適切に生成します。
    *   **メソッド**: 欠落している型に対するメソッド呼び出しをスキャンし、シグネチャ（名前、引数数/型）を推論します。戻り値の型は、そのメソッドの戻り値が代入される変数、キャスト情報、あるいはメソッドチェーンでの使用状況などから推論します。
    *   **フィールド**: フィールドアクセスをスキャンし、publicフィールドを生成します。
4.  **生成**: 推論された情報に基づいて、有効なJavaソースファイルを生成します。
